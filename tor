package pl.santander.clp.product.common.productrelation;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

import pl.santander.clp.product.common.relations.snapshot.ProductRelationSnapshot;
import pl.santander.clp.product.common.relations.snapshot.ProductRelationsSnapshot;
import pl.santander.clp.product.common.relations.snapshot.ProductsRelationType;

class ProductRelationComparatorTest {

    private ProductRelationComparator comparator;

    @BeforeEach
    void setUp() {
        comparator = new ProductRelationComparator();
    }

    @Test
    void shouldReturnTrueWhenRelationsAreEqual() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
                createRelationSnapshot(1L, 102L, ProductsRelationType.RENEWAL)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION),
            createRelationDto(1L, 102L, ProductRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "Relations should be equal when they contain the same elements");
    }

    @Test
    void shouldReturnFalseWhenRelationsAreDifferent() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION)
            ),
            createProductRelationsSnapshot(3L,
                createRelationSnapshot(3L, 103L, ProductsRelationType.ACTIVATION)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION),
            createRelationDto(2L, 102L, ProductRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L, 3L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when they contain different elements");
    }

    @Test
    void shouldFilterOutLaunchOrderAndLaunchedRelations() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
                createRelationSnapshot(1L, 102L, ProductsRelationType.LAUNCH_ORDER),
                createRelationSnapshot(1L, 103L, ProductsRelationType.LAUNCHED)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION)
        );
        
        Set<Long> productIds = Set.of(1L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "LAUNCH_ORDER and LAUNCHED relations should be filtered out");
    }

    @Test
    void shouldConvertCorrectionToModification() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.CORRECTION)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION)
        );
        
        Set<Long> productIds = Set.of(1L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "CORRECTION should be converted to MODIFICATION");
    }

    @Test
    void shouldHandleEmptyRelations() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = new HashSet<>();
        Set<ProductRelationDto> legacyRelations = new HashSet<>();
        Set<Long> productIds = Set.of(1L, 2L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "Empty relations should be considered equal");
    }

    @Test
    void shouldReturnFalseWhenNewRelationsContainMoreItems() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
                createRelationSnapshot(1L, 102L, ProductsRelationType.RENEWAL)
            ),
            createProductRelationsSnapshot(3L,
                createRelationSnapshot(3L, 103L, ProductsRelationType.ABSORPTION)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION),
            createRelationDto(1L, 102L, ProductRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 3L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when new relations contain more items");
    }

    @Test
    void shouldReturnFalseWhenLegacyRelationsContainMoreItems() {
        // Given
        Set<ProductRelationsSnapshot> newRelations = Set.of(
            createProductRelationsSnapshot(1L,
                createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION)
            )
        );
        
        Set<ProductRelationDto> legacyRelations = createRelationDtos(
            createRelationDto(1L, 101L, ProductRelationType.MODIFICATION),
            createRelationDto(2L, 102L, ProductRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when legacy relations contain more items");
    }

    // Helper methods
    private ProductRelationSnapshot createRelationSnapshot(Long sourceId, Long targetId, ProductsRelationType type) {
        return ProductRelationSnapshot.builder()
            .sourceId(sourceId)
            .targetId(targetId)
            .relationType(type)
            .build();
    }
    
    private ProductRelationsSnapshot createProductRelationsSnapshot(Long productId, ProductRelationSnapshot... relations) {
        ProductRelationsSnapshot snapshot = ProductRelationsSnapshot.builder()
            .productId(productId)
            .build();
        
        for (ProductRelationSnapshot relation : relations) {
            snapshot.getRelations().add(relation);
        }
        
        return snapshot;
    }
    
    private ProductRelationDto createRelationDto(Long sourceId, Long targetId, ProductRelationType type) {
        return ProductRelationDto.builder()
            .sourceId(sourceId)
            .targetId(targetId)
            .type(type)
            .build();
    }
    
    private Set<ProductRelationDto> createRelationDtos(ProductRelationDto... dtos) {
        return new HashSet<>(Arrays.asList(dtos));
    }
}
