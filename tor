package pl.santander.clp.product.common.relations.snapshot;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import pl.santander.clp.product.common.relations.RelationDetails;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

class RelationDetailsImplTest {
    private static final Set<ProductRelationSnapshot> relations = new HashSet<>();
    final static Long confirmedProductId = 1L;
    final static Long pricingProduct = 3L;

    @BeforeAll
    static void setUp() {
        EnumSet<ProductsRelationType> productsRelationTypes = EnumSet.allOf(ProductsRelationType.class);
        productsRelationTypes.forEach(relationType -> {
            relations.add(
                ProductRelationSnapshot.builder()
                    .relationType(relationType)
                    .sourceId(confirmedProductId)
                    .targetId(pricingProduct)
                    .build()
            );
        });
    }

    // ===== MODIFICATION TESTS =====

    @ParameterizedTest
    @MethodSource("isModificationSource")
    void isModificationTest(Long modificationId, 
                          Set<ProductRelationSnapshot> relations,
                          Long modifiedProductId) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(modificationId, relations);
        
        // when & then
        assertEquals(modifiedProductId != null, relationDetails.isModification());
        assertEquals(modifiedProductId, relationDetails.getModifiedProductId());
    }
    
    static Stream<Arguments> isModificationSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), null));
        
        // all possible relations
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId));
        
        // all possible relations without MODIFICATION
        Set<ProductRelationSnapshot> relationsWithoutModification = relations
            .stream()
            .filter(r -> r.getRelationType() != ProductsRelationType.MODIFICATION)
            .collect(Collectors.toSet());
        builder.add(Arguments.of(pricingProduct, relationsWithoutModification, null));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("isModificationSourceProductSource")
    void isModificationSourceProductTest(Long modificationId, 
                                        Set<ProductRelationSnapshot> relations,
                                        boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(modificationId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isModificationSourceProduct());
    }
    
    static Stream<Arguments> isModificationSourceProductSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), false));
        
        // all possible relations - confirmedProductId is the source
        builder.add(Arguments.of(confirmedProductId, relations, true));
        
        // all possible relations - pricingProduct is the target
        builder.add(Arguments.of(pricingProduct, relations, false));
        
        return builder.build();
    }

    // ===== ACTIVATION TESTS =====

    @ParameterizedTest
    @MethodSource("isActivationSource")
    void isActivationTest(Long activationId, 
                        Set<ProductRelationSnapshot> relations,
                        Long activatedProductId) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(activationId, relations);
        
        // when & then
        assertEquals(activatedProductId != null, relationDetails.isActivation());
        assertEquals(activatedProductId, relationDetails.getActivatedProductId());
    }
    
    static Stream<Arguments> isActivationSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), null));
        
        // all possible relations
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId));
        
        // all possible relations without ACTIVATION
        Set<ProductRelationSnapshot> relationsWithoutActivation = relations
            .stream()
            .filter(r -> r.getRelationType() != ProductsRelationType.ACTIVATION)
            .collect(Collectors.toSet());
        builder.add(Arguments.of(pricingProduct, relationsWithoutActivation, null));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("isActivationSourceProductSource")
    void isActivationSourceProductTest(Long activationId, 
                                      Set<ProductRelationSnapshot> relations,
                                      boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(activationId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isActivationSourceProduct());
    }
    
    static Stream<Arguments> isActivationSourceProductSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), false));
        
        // all possible relations - confirmedProductId is the source
        builder.add(Arguments.of(confirmedProductId, relations, true));
        
        // all possible relations - pricingProduct is the target
        builder.add(Arguments.of(pricingProduct, relations, false));
        
        return builder.build();
    }

    // ===== RENEWAL TESTS =====

    @ParameterizedTest
    @MethodSource("isRenewalSource")
    void isRenewalTest(Long renewalId, 
                      Set<ProductRelationSnapshot> relations,
                      Long renewedProductId) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(renewalId, relations);
        
        // when & then
        assertEquals(renewedProductId != null, relationDetails.isRenewal());
        assertEquals(renewedProductId, relationDetails.getRenewedProductId());
    }
    
    static Stream<Arguments> isRenewalSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), null));
        
        // all possible relations
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId));
        
        // all possible relations without RENEWAL
        Set<ProductRelationSnapshot> relationsWithoutRenewal = relations
            .stream()
            .filter(r -> r.getRelationType() != ProductsRelationType.RENEWAL)
            .collect(Collectors.toSet());
        builder.add(Arguments.of(pricingProduct, relationsWithoutRenewal, null));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("isRenewalSourceProductSource")
    void isRenewalSourceProductTest(Long renewalId, 
                                   Set<ProductRelationSnapshot> relations,
                                   boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(renewalId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isRenewalSourceProduct());
    }
    
    static Stream<Arguments> isRenewalSourceProductSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), false));
        
        // all possible relations - confirmedProductId is the source
        builder.add(Arguments.of(confirmedProductId, relations, true));
        
        // all possible relations - pricingProduct is the target
        builder.add(Arguments.of(pricingProduct, relations, false));
        
        return builder.build();
    }

    // ===== RESIGNATION TESTS =====

    @ParameterizedTest
    @MethodSource("isResignationSource")
    void isResignationTest(Long resignationId, 
                          Set<ProductRelationSnapshot> relations,
                          Long resignedProductId) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(resignationId, relations);
        
        // when & then
        assertEquals(resignedProductId != null, relationDetails.isResignation());
        assertEquals(resignedProductId, relationDetails.getResignedProductId());
    }
    
    static Stream<Arguments> isResignationSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), null));
        
        // all possible relations
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId));
        
        // all possible relations without RESIGNATION
        Set<ProductRelationSnapshot> relationsWithoutResignation = relations
            .stream()
            .filter(r -> r.getRelationType() != ProductsRelationType.RESIGNATION)
            .collect(Collectors.toSet());
        builder.add(Arguments.of(pricingProduct, relationsWithoutResignation, null));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("isResignationSourceProductSource")
    void isResignationSourceProductTest(Long resignationId, 
                                       Set<ProductRelationSnapshot> relations,
                                       boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(resignationId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isResignationSourceProduct());
    }
    
    static Stream<Arguments> isResignationSourceProductSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), false));
        
        // all possible relations - confirmedProductId is the source
        builder.add(Arguments.of(confirmedProductId, relations, true));
        
        // all possible relations - pricingProduct is the target
        builder.add(Arguments.of(pricingProduct, relations, false));
        
        return builder.build();
    }

    // ===== REFINANCING TESTS =====

    @ParameterizedTest
    @MethodSource("isRefinancedBySource")
    void isRefinancedByTest(Long productId, 
                           Set<ProductRelationSnapshot> relations,
                           Long otherProductId,
                           boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(productId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isRefinancedBy(otherProductId));
    }
    
    static Stream<Arguments> isRefinancedBySource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), pricingProduct, false));
        
        // confirmedProductId is source of REFINANCING to pricingProduct - should be true
        builder.add(Arguments.of(confirmedProductId, relations, pricingProduct, true));
        
        // pricingProduct is target of REFINANCING from confirmedProductId - should be false
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId, false));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("doesRefinanceSource")
    void doesRefinanceTest(Long productId, 
                          Set<ProductRelationSnapshot> relations,
                          Long otherProductId,
                          boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(productId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.doesRefinance(otherProductId));
    }
    
    static Stream<Arguments> doesRefinanceSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), confirmedProductId, false));
        
        // pricingProduct is target of REFINANCING from confirmedProductId - should be true
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId, true));
        
        // confirmedProductId is source of REFINANCING to pricingProduct - should be false
        builder.add(Arguments.of(confirmedProductId, relations, pricingProduct, false));
        
        return builder.build();
    }

    // ===== ABSORPTION TESTS =====

    @ParameterizedTest
    @MethodSource("isAbsorbedBySource")
    void isAbsorbedByTest(Long productId, 
                         Set<ProductRelationSnapshot> relations,
                         Long otherProductId,
                         boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(productId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isAbsorbedBy(otherProductId));
    }
    
    static Stream<Arguments> isAbsorbedBySource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), pricingProduct, false));
        
        // confirmedProductId is source of ABSORPTION to pricingProduct - should be true
        builder.add(Arguments.of(confirmedProductId, relations, pricingProduct, true));
        
        // pricingProduct is target of ABSORPTION from confirmedProductId - should be false
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId, false));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("doesAbsorbSource")
    void doesAbsorbTest(Long productId, 
                       Set<ProductRelationSnapshot> relations,
                       Long otherProductId,
                       boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(productId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.doesAbsorb(otherProductId));
    }
    
    static Stream<Arguments> doesAbsorbSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), confirmedProductId, false));
        
        // pricingProduct is target of ABSORPTION from confirmedProductId - should be true
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId, true));
        
        // confirmedProductId is source of ABSORPTION to pricingProduct - should be false
        builder.add(Arguments.of(confirmedProductId, relations, pricingProduct, false));
        
        return builder.build();
    }

    // ===== CORRECTION TESTS =====

    @ParameterizedTest
    @MethodSource("isCorrectionSource")
    void isCorrectionTest(Long correctionId, 
                         Set<ProductRelationSnapshot> relations,
                         Long correctedProductId) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(correctionId, relations);
        
        // when & then
        assertEquals(correctedProductId != null, relationDetails.isCorrection());
        assertEquals(correctedProductId, relationDetails.getCorrectedProductId());
    }
    
    static Stream<Arguments> isCorrectionSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(pricingProduct, Set.of(), null));
        
        // all possible relations
        builder.add(Arguments.of(pricingProduct, relations, confirmedProductId));
        
        // all possible relations without CORRECTION
        Set<ProductRelationSnapshot> relationsWithoutCorrection = relations
            .stream()
            .filter(r -> r.getRelationType() != ProductsRelationType.CORRECTION)
            .collect(Collectors.toSet());
        builder.add(Arguments.of(pricingProduct, relationsWithoutCorrection, null));
        
        return builder.build();
    }

    @ParameterizedTest
    @MethodSource("isCorrectedSource")
    void isCorrectedTest(Long correctionId, 
                       Set<ProductRelationSnapshot> relations,
                       boolean expected) {
        // given
        RelationDetailsService relationDetails = new RelationDetailsService(correctionId, relations);
        
        // when & then
        assertEquals(expected, relationDetails.isCorrected());
    }
    
    static Stream<Arguments> isCorrectedSource() {
        Stream.Builder<Arguments> builder = Stream.builder();
        
        // empty relations case
        builder.add(Arguments.of(confirmedProductId, Set.of(), false));
        
        // all possible relations - confirmedProductId is the source
        builder.add(Arguments.of(confirmedProductId, relations, true));
        
        // all possible relations - pricingProduct is the target
        builder.add(Arguments.of(pricingProduct, relations, false));
        
        return builder.build();
    }
}
