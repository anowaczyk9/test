package pl.santander.clp.product.common.productrelation;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

import pl.santander.clp.product.common.relations.snapshot.ProductRelationSnapshot;
import pl.santander.clp.product.common.relations.snapshot.ProductsRelationType;

class ProductRelationComparatorTest {

    private ProductRelationComparator comparator;

    @BeforeEach
    void setUp() {
        comparator = new ProductRelationComparator();
    }

    @Test
    void shouldReturnTrueWhenRelationsAreEqual() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "Relations should be equal when they contain the same elements");
    }

    @Test
    void shouldReturnFalseWhenRelationsAreDifferent() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(3L, 103L, ProductsRelationType.ACTIVATION)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L, 3L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when they contain different elements");
    }

    @Test
    void shouldFilterOutLaunchOrderAndLaunchedRelations() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.LAUNCH_ORDER),
            createRelationSnapshot(3L, 103L, ProductsRelationType.LAUNCHED)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION)
        );
        
        Set<Long> productIds = Set.of(1L, 2L, 3L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "LAUNCH_ORDER and LAUNCHED relations should be filtered out");
    }

    @Test
    void shouldConvertCorrectionToModification() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.CORRECTION)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION)
        );
        
        Set<Long> productIds = Set.of(1L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "CORRECTION should be converted to MODIFICATION");
    }

    @Test
    void shouldHandleEmptyRelations() {
        // Given
        Set<ProductRelationSnapshot> newRelations = new HashSet<>();
        Set<ProductRelationSnapshot> legacyRelations = new HashSet<>();
        Set<Long> productIds = Set.of(1L, 2L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertTrue(result, "Empty relations should be considered equal");
    }

    @Test
    void shouldReturnFalseWhenNewRelationsContainMoreItems() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL),
            createRelationSnapshot(3L, 103L, ProductsRelationType.ABSORPTION)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L, 3L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when new relations contain more items");
    }

    @Test
    void shouldReturnFalseWhenLegacyRelationsContainMoreItems() {
        // Given
        Set<ProductRelationSnapshot> newRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION)
        );
        
        Set<ProductRelationSnapshot> legacyRelations = createRelationSnapshots(
            createRelationSnapshot(1L, 101L, ProductsRelationType.MODIFICATION),
            createRelationSnapshot(2L, 102L, ProductsRelationType.RENEWAL)
        );
        
        Set<Long> productIds = Set.of(1L, 2L);

        // When
        boolean result = comparator.compareWithNewRelations(newRelations, legacyRelations, productIds);

        // Then
        assertFalse(result, "Relations should not be equal when legacy relations contain more items");
    }

    // Helper methods
    private ProductRelationSnapshot createRelationSnapshot(Long sourceId, Long targetId, ProductsRelationType type) {
        return ProductRelationSnapshot.builder()
            .sourceId(sourceId)
            .targetId(targetId)
            .relationType(type)
            .build();
    }

    private Set<ProductRelationSnapshot> createRelationSnapshots(ProductRelationSnapshot... snapshots) {
        return new HashSet<>(Arrays.asList(snapshots));
    }
}
