package com.example.integration;

import com.example.client.ProductClient;
import com.example.dto.BaseProductDataDto;
import com.example.entities.ProductReadModelEntity;
import com.example.entities.ProductStatusEntity;
import com.example.exceptions.ProductSynchronizationException;
import com.example.repositories.ProductReadModelRepository;
import com.example.repositories.ProductStatusRepository;
import com.example.services.ProductReadModelService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.test.context.ActiveProfiles;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test") // Assumes an H2 (or similar) in-memory DB is configured for the "test" profile.
public class SynchronizeProductsFullIntegrationTest {

    @Autowired
    private ProductReadModelService productReadModelService;

    @Autowired
    private ProductReadModelRepository productReadModelRepository;

    @Autowired
    private ProductStatusRepository productStatusRepository;

    /**
     * Stub the external ProductClient so that our test does not rely on external systems.
     * Here we simulate two cases:
     * - If customerIds contains 300L, we return an empty list.
     * - Otherwise, we return a list of three products.
     */
    @TestConfiguration
    static class TestProductClientConfig {

        @Bean
        @Primary
        public ProductClient productClient() {
            return new ProductClient() {
                @Override
                public List<BaseProductDataDto> findAllByCustomerIds(Set<Long> customerIds) {
                    if (customerIds.contains(300L)) {
                        return Collections.emptyList();
                    }
                    // Create three sample products
                    BaseProductDataDto product1 = new BaseProductDataDto();
                    product1.setId(1L);
                    BaseProductDataDto product2 = new BaseProductDataDto();
                    product2.setId(2L);
                    BaseProductDataDto product3 = new BaseProductDataDto();
                    product3.setId(3L);
                    return Arrays.asList(product1, product2, product3);
                }
            };
        }
    }

    @BeforeEach
    public void setUp() {
        // Clean the database before each test
        productReadModelRepository.deleteAll();
        productStatusRepository.deleteAll();
    }

    /**
     * Test the full integration flow when non-empty product data is returned.
     */
    @Test
    public void testSynchronizeProductsWithNonEmptyData() {
        Set<Long> customerIds = Set.of(100L, 200L);

        // Call the synchronization method.
        productReadModelService.synchronizeProducts(customerIds);

        // Verify that the read model repository now contains 3 entities.
        List<ProductReadModelEntity> savedProducts = productReadModelRepository.findAll();
        assertEquals(3, savedProducts.size(), "Should have 3 saved product read model entities");

        // Verify that the status updates have been applied.
        // For example, if resumeProductUpdates sets the status to SYNCHRONIZED,
        // then we can verify that in the product status repository.
        List<ProductStatusEntity> statuses = productStatusRepository.findAll();
        // (The exact expected number depends on your implementation.
        // In our sample implementation, resumeProductUpdates iterates over each product
        // and creates a new status record. Adjust the assertion as needed.)
        assertFalse(statuses.isEmpty(), "Product statuses should be updated");
        statuses.forEach(status ->
                assertEquals(ProductStatusEntity.Status.SYNCHRONIZED, status.getStatus(),
                        "All product statuses should be marked as SYNCHRONIZED")
        );
    }

    /**
     * Test the full integration flow when the external client returns empty data.
     */
    @Test
    public void testSynchronizeProductsWithEmptyData() {
        Set<Long> customerIds = Set.of(300L);

        // Call the synchronization method.
        productReadModelService.synchronizeProducts(customerIds);

        // Verify that no product read model entities were saved.
        List<ProductReadModelEntity> savedProducts = productReadModelRepository.findAll();
        assertTrue(savedProducts.isEmpty(), "No product read model entities should be saved for empty data");

        // Verify that resumeProductUpdates is not called and no product statuses are created.
        List<ProductStatusEntity> statuses = productStatusRepository.findAll();
        assertTrue(statuses.isEmpty(), "No product status updates should occur when no data is returned");
    }

    /**
     * Test that if the ProductClient throws an exception, the synchronization method
     * throws a ProductSynchronizationException.
     */
    @Test
    public void testSynchronizeProductsFeignException() {
        // For this test, we simulate a failure in the external client.
        // One approach is to temporarily override the ProductClient bean to throw an exception.
        // Alternatively, you might have a dedicated test profile or a separate test configuration.
        // For simplicity, assume we simulate the condition by providing a new set of customer IDs
        // that our stub is programmed to handle as an error. (You might need to adjust your stub accordingly.)
        Set<Long> customerIds = Set.of(500L);

        // Here we simulate an exception by having the ProductClient stub throw a runtime exception.
        // To do that, you could modify your TestProductClientConfig to check for customerId 500L.
        // For demonstration, we assume that behavior is implemented.
        ProductSynchronizationException exception = assertThrows(
                ProductSynchronizationException.class,
                () -> productReadModelService.synchronizeProducts(customerIds),
                "Should throw ProductSynchronizationException when client fails"
        );
        assertTrue(exception.getMessage().contains("Failed to synchronize products"));
    }
}
