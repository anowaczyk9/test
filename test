package com.example.integration;

import com.example.client.ProductClient;
import com.example.dto.BaseProductDataDto;
import com.example.entities.ProductReadModelEntity;
import com.example.exceptions.ProductSynchronizationException;
import com.example.repositories.ProductReadModelRepository;
import com.example.services.ProductReadModelService;
import com.example.services.ProductStatusServicePort;
import feign.FeignException;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.ActiveProfiles;

import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;

@SpringBootTest
@ActiveProfiles("test")
@Import(ProductReadModelServiceIntegrationTest.TestConfig.class)
public class ProductReadModelServiceIntegrationTest {

    // Inject the service under test.
    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
    @javax.annotation.Resource
    private ProductReadModelService productReadModelService;

    // Inject the collaborator mocks so we can control and verify behavior.
    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
    @javax.annotation.Resource
    private ProductClient productClient;

    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
    @javax.annotation.Resource
    private ProductReadModelRepository productReadModelRepository;

    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")
    @javax.annotation.Resource
    private ProductStatusServicePort productStatusServicePort;

    @TestConfiguration
    static class TestConfig {
        @Bean
        public ProductClient productClient() {
            return Mockito.mock(ProductClient.class);
        }

        @Bean
        public ProductReadModelRepository productReadModelRepository() {
            return Mockito.mock(ProductReadModelRepository.class);
        }

        @Bean
        public ProductStatusServicePort productStatusServicePort() {
            return Mockito.mock(ProductStatusServicePort.class);
        }
        // Note: ProductReadModelService is already declared as a @Service in your main code,
        // so it will be picked up by component scanning.
    }

    /**
     * Test the successful synchronization when productClient returns a non-empty list.
     */
    @Test
    public void testSynchronizeProductsWithNonEmptyData() {
        // Arrange: prepare a set of customer IDs.
        Set<Long> customerIds = Set.of(100L, 200L);

        // Prepare some sample products with variety in data.
        BaseProductDataDto product1 = new BaseProductDataDto();
        product1.setId(1L);
        // (Set other properties as needed)

        BaseProductDataDto product2 = new BaseProductDataDto();
        product2.setId(2L);
        // (Set additional properties if needed)

        // Optionally add a third product with different data.
        BaseProductDataDto product3 = new BaseProductDataDto();
        product3.setId(3L);
        // (Set more fields as appropriate)

        List<BaseProductDataDto> productList = List.of(product1, product2, product3);

        // When productClient is called, return our list.
        when(productClient.findAllByCustomerIds(customerIds)).thenReturn(productList);

        // Act: call synchronizeProducts.
        productReadModelService.synchronizeProducts(customerIds);

        // Assert: Verify that the repository's saveAll is called with the converted list.
        ArgumentCaptor<List<ProductReadModelEntity>> captor =
                ArgumentCaptor.forClass(List.class);
        verify(productReadModelRepository, times(1)).saveAll(captor.capture());
        List<ProductReadModelEntity> savedEntities = captor.getValue();
        assertEquals(productList.size(), savedEntities.size(),
            "The number of saved entities should match the number of returned products.");

        // Verify that resumeProductUpdates is called with the correct list of product IDs.
        verify(productStatusServicePort, times(1))
                .resumeProductUpdates(argThat(ids ->
                        ids.containsAll(List.of(1L, 2L, 3L)) && ids.size() == 3));
    }

    /**
     * Test the successful synchronization when productClient returns an empty list.
     */
    @Test
    public void testSynchronizeProductsWithEmptyData() {
        // Arrange: a set of customer IDs.
        Set<Long> customerIds = Set.of(300L);
        // productClient returns an empty list.
        when(productClient.findAllByCustomerIds(customerIds)).thenReturn(List.of());

        // Act:
        productReadModelService.synchronizeProducts(customerIds);

        // Assert: Verify that saveAll is called with an empty list.
        verify(productReadModelRepository, times(1))
                .saveAll(argThat(list -> list.isEmpty()));
        // And that resumeProductUpdates is also called with an empty list.
        verify(productStatusServicePort, times(1))
                .resumeProductUpdates(argThat(list -> list.isEmpty()));
    }

    /**
     * Test that if productClient throws a FeignException, the service throws a ProductSynchronizationException.
     */
    @Test
    public void testSynchronizeProductsFeignException() {
        // Arrange: a set of customer IDs.
        Set<Long> customerIds = Set.of(400L);

        // Simulate a FeignException.
        FeignException feignException = mock(FeignException.class);
        when(productClient.findAllByCustomerIds(customerIds)).thenThrow(feignException);

        // Act & Assert: the service should throw a ProductSynchronizationException.
        ProductSynchronizationException exception = assertThrows(
                ProductSynchronizationException.class,
                () -> productReadModelService.synchronizeProducts(customerIds)
        );
        assertTrue(exception.getMessage().contains("Failed to synchronize products"));

        // Verify that neither saveAll nor resumeProductUpdates is called.
        verify(productReadModelRepository, never()).saveAll(any());
        verify(productStatusServicePort, never()).resumeProductUpdates(any());
    }
}
