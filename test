import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
class DatabaseHealthCheckerTest {

    @Mock
    private BindingsLifecycleController bindingsLifecycleController;

    @Mock
    private DataSource dataSource;

    @Mock
    private Connection connection;

    @Mock
    private Statement statement;

    @InjectMocks
    private DatabaseHealthChecker databaseHealthChecker;

    // Ensure our binding name is set for the tests.
    @BeforeEach
    void setup() {
        ReflectionTestUtils.setField(databaseHealthChecker, "productChangedEventBindingName", "test-binding");
    }

    /**
     * Test that when the database is healthy, no change in health state occurs and no lifecycle
     * method is called.
     */
    @Test
    void testHealthyRemainsHealthy() throws Exception {
        // Arrange: simulate a healthy database connection.
        when(dataSource.getConnection()).thenReturn(connection);
        when(connection.createStatement()).thenReturn(statement);
        // The SELECT statement executes without error.
        doNothing().when(statement).execute("SELECT 1");

        // Act: call the scheduled method.
        databaseHealthChecker.checkDatabaseHealth();

        // Assert: since the initial state is healthy and remains healthy,
        // neither start() nor stop() should be called.
        verify(bindingsLifecycleController, never()).start(anyString());
        verify(bindingsLifecycleController, never()).stop(anyString());
        assertTrue(databaseHealthChecker.isDatabaseHealthy());
    }

    /**
     * Test that when the database transitions from healthy to unhealthy the
     * stop method is called.
     */
    @Test
    void testHealthyToUnhealthyTransition() throws Exception {
        // Arrange: simulate a failure in obtaining a connection (or executing the query).
        when(dataSource.getConnection()).thenThrow(new SQLException("Simulated failure"));

        // Act: call the scheduled method.
        databaseHealthChecker.checkDatabaseHealth();

        // Assert: since the initial state was healthy and now it's unhealthy,
        // we expect the stop method to be called.
        verify(bindingsLifecycleController, times(1)).stop("test-binding");
        verify(bindingsLifecycleController, never()).start(anyString());
        assertFalse(databaseHealthChecker.isDatabaseHealthy());
    }

    /**
     * Test that when the database transitions from unhealthy to healthy the
     * start method is called.
     */
    @Test
    void testUnhealthyToHealthyTransition() throws Exception {
        // First, force an unhealthy state.
        when(dataSource.getConnection()).thenThrow(new SQLException("Simulated failure"));
        databaseHealthChecker.checkDatabaseHealth();
        assertFalse(databaseHealthChecker.isDatabaseHealthy());

        // Reset mocks before simulating a healthy scenario.
        reset(dataSource, connection, statement, bindingsLifecycleController);

        // Arrange: simulate a healthy database connection.
        when(dataSource.getConnection()).thenReturn(connection);
        when(connection.createStatement()).thenReturn(statement);
        doNothing().when(statement).execute("SELECT 1");

        // Act: call the scheduled method.
        databaseHealthChecker.checkDatabaseHealth();

        // Assert: since the state changed from unhealthy to healthy, we expect the start method to be called.
        verify(bindingsLifecycleController, times(1)).start("test-binding");
        verify(bindingsLifecycleController, never()).stop(anyString());
        assertTrue(databaseHealthChecker.isDatabaseHealthy());
    }
}
